type WithdrawReceipt = 
 variant {
   Err: WithdrawErr;
   Ok: nat;
 };
type WithdrawErr = 
 variant {
   BalanceLow;
   TransferFailure;
 };
type TxReceipt = 
 variant {
   Err:
    variant {
      AmountTooSmall;
      BlockUsed;
      ErrorOperationStyle;
      ErrorTo;
      InsufficientAllowance;
      InsufficientBalance;
      LedgerTrap;
      Other;
      Unauthorized;
    };
   Ok: nat;
 };
type Transaction = 
 record {
   created_at_time: TimeStamp;
   memo: Memo;
   operation: opt Operation;
 };
type Tokens = record {e8s: nat64;};
type Token = principal;
type TimeStamp = record {timestamp_nanos: nat64;};
type Result = 
 variant {
   err: DecodeError;
   ok: vec nat8;
 };
type QueryBlocksResponse = 
 record {
   archived_blocks:
    vec record {
          callback: QueryArchiveFn;
          length: nat64;
          start: BlockIndex;
        };
   blocks: vec Block;
   certificate: opt vec nat8;
   chain_length: nat64;
   first_block_index: BlockIndex;
 };
type QueryArchiveResult = 
 variant {
   Err: QueryArchiveError;
   Ok: BlockRange;
 };
type QueryArchiveFn = func (GetBlocksArgs) -> (QueryArchiveResult) query;
type QueryArchiveError = 
 variant {
   BadFirstBlockIndex:
    record {
      first_valid_index: BlockIndex;
      requested_index: BlockIndex;
    };
   Other: record {
            error_code: nat64;
            error_message: text;
          };
 };
type Operation = 
 variant {
   Burn: record {
           amount: Tokens;
           from: AccountIdentifier;
         };
   Mint: record {
           amount: Tokens;
           to: AccountIdentifier;
         };
   Transfer:
    record {
      amount: Tokens;
      fee: Tokens;
      from: AccountIdentifier;
      to: AccountIdentifier;
    };
 };
type Memo = nat64;
type GetBlocksArgs = 
 record {
   length: nat64;
   start: BlockIndex;
 };
type Finrisk = 
 service {
   account_test: (text) -> (AccountIdentifier__1, Result);
   borrow: (Token, nat) -> (TxReceipt);
   debug_accrue_interest: (Token, nat, nat, nat, nat, nat, nat, nat) ->
    (text);
   debug_get_account_liquidity: (principal) -> (text);
   debug_get_exchange_rate: (Token) -> (text) query;
   deposit_dip: (Token) -> (DepositReceipt);
   deposit_icp: (BlockIndex, variant {
                               Mint;
                               Repay;
                             }) -> (DepositReceipt);
   find_tx_id: (BlockIndex, principal, variant {
                                         Mint;
                                         Repay;
                                       }) -> (bool);
   generate_archive_canister: () -> (principal);
   get_market_balance: (Token, principal) -> (nat) query;
   get_market_borrow_balance: (Token, principal) -> (nat) query;
   get_off_ramp_balances: () -> (text);
   get_or_create_market: (Token, nat, nat, nat, nat, nat, nat, nat, nat) ->
    (bool);
   get_this_account_id_as_text: () -> (text, text);
   icp_sent_from_principal: (BlockIndex, principal, variant {
                                                      Mint;
                                                      Repay;
                                                    }) -> (nat64);
   liquidate: (Token, Token, principal, nat) -> (TxReceipt);
   mint: (Token, nat) -> (TxReceipt);
   redeem: (Token, nat) -> (TxReceipt);
   repay: (Token, nat) -> (TxReceipt);
   view_archive_principals: () -> (vec principal);
   view_blocks: (BlockIndex) -> (QueryBlocksResponse);
   withdraw_dip: (Token, nat, principal) -> (WithdrawReceipt);
   withdraw_icp: (nat, text) -> (WithdrawReceipt);
 };
type DepositReceipt = 
 variant {
   Err: DepositErr;
   Ok: nat;
 };
type DepositErr = 
 variant {
   BalanceLow;
   BlockUsed;
   TransferFailure;
   ZeroDepositOrNoBlockFound;
 };
type DecodeError = variant {msg: text;};
type BlockRange = record {blocks: vec Block;};
type BlockIndex = nat64;
type Block = 
 record {
   parent_hash: opt vec nat8;
   timestamp: TimeStamp;
   transaction: Transaction;
 };
type AccountIdentifier__1 = vec nat8;
type AccountIdentifier = vec nat8;
service : (principal) -> Finrisk
